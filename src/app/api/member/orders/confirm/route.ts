/**
 * Order Confirmation API (Unified B2B + Member)
 *
 * Task 110: Order Confirmation Flow
 * - POST: Convert an APPROVED quotation to an order
 * - GET: Check if quotation can be confirmed
 *
 * Process:
 * 1. Receive quotation_id
 * 2. Validate quotation status (must be APPROVED)
 * 3. Create order from quotation data
 * 4. Copy items from quotation_items to order_items
 * 5. Generate order number (auto-generated by database trigger)
 * 6. Set initial order status (QUOTATION)
 * 7. Update quotation status (if needed)
 *
 * Database Operations:
 * - Uses Supabase client for all DB operations
 * - Transaction-safe: order creation + items copy
 * - Supports both B2B (company_id) and Member (user_id) patterns
 */

import { NextRequest, NextResponse } from 'next/server';
import { cookies } from 'next/headers';
import { createClient } from '@supabase/supabase-js';
import type { OrderStatus } from '@/types/order-status';

// Environment variables
const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseAnonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

/**
 * Helper function to create authenticated Supabase client
 */
async function createAuthenticatedClient() {
  const cookieStore = await cookies();
  return createClient(supabaseUrl, supabaseAnonKey, {
    auth: {
      storage: {
        getItem: (key: string) => {
          const cookie = cookieStore.get(key);
          return cookie?.value ?? null;
        },
        setItem: (key: string, value: string) => {
          cookieStore.set(key, value, {
            httpOnly: true,
            secure: process.env.NODE_ENV === 'production',
            sameSite: 'lax',
            path: '/',
          });
        },
        removeItem: (key: string) => {
          cookieStore.delete(key);
        },
      },
    },
  });
}

/**
 * Request types
 */
interface ConfirmOrderRequest {
  quotationId: string;
}

interface ConfirmOrderResponse {
  success: true;
  orderId: string;
  orderNumber: string;
  message: string;
  messageEn: string;
}

interface ConfirmOrderErrorResponse {
  success: false;
  error: string;
  errorEn: string;
  details?: string;
}

/**
 * POST /api/member/orders/confirm
 * Confirm order from an APPROVED quotation
 *
 * Request Body:
 * {
 *   "quotationId": "string"
 * }
 *
 * Success Response (200):
 * {
 *   "success": true,
 *   "orderId": "string",
 *   "orderNumber": "string",
 *   "message": "注文を作成しました。",
 *   "messageEn": "Order created successfully."
 * }
 */
export async function POST(request: NextRequest) {
  try {
    // 1. Authenticate user (support both cookie auth and DEV_MODE header)
    const cookieStore = await cookies();
    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        storage: {
          getItem: (key: string) => {
            const cookie = cookieStore.get(key);
            return cookie?.value ?? null;
          },
          setItem: (key: string, value: string) => {
            cookieStore.set(key, value, {
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax',
              path: '/',
            });
          },
          removeItem: (key: string) => {
            cookieStore.delete(key);
          },
        },
      },
    });

    // Check for DEV_MODE header from middleware
    const devModeUserId = request.headers.get('x-user-id');
    const isDevMode = request.headers.get('x-dev-mode') === 'true';

    let userId: string;

    if (isDevMode && devModeUserId) {
      // DEV_MODE: Use header from middleware
      console.log('[Order Confirm API] DEV_MODE: Using x-user-id header:', devModeUserId);
      userId = devModeUserId;
    } else {
      // Normal auth: Use cookie-based auth
      const { data: { user }, error: userError } = await supabase.auth.getUser();

      if (userError || !user?.id) {
        return NextResponse.json(
          {
            success: false,
            error: '認証されていません。',
            errorEn: 'Authentication required'
          },
          { status: 401 }
        );
      }
      userId = user.id;
    }

    // 2. Parse and validate request body
    const body: ConfirmOrderRequest = await request.json();

    if (!body.quotationId) {
      return NextResponse.json(
        {
          success: false,
          error: '見積IDは必須です。',
          errorEn: 'quotationId is required'
        },
        { status: 400 }
      );
    }

    // 3. Fetch quotation with validation
    const { data: quotation, error: quotationError } = await supabase
      .from('quotations')
      .select(`
        id,
        quotation_number,
        status,
        user_id,
        customer_name,
        customer_email,
        customer_phone,
        subtotal_amount,
        tax_amount,
        total_amount,
        notes,
        estimated_delivery_date,
        quotation_items (
          id,
          product_id,
          product_name,
          quantity,
          unit_price,
          total_price,
          specifications
        )
      `)
      .eq('id', body.quotationId)
      .eq('user_id', userId)
      .single();

    if (quotationError || !quotation) {
      return NextResponse.json(
        {
          success: false,
          error: '見積が見つかりません。',
          errorEn: 'Quotation not found',
          details: quotationError?.message
        },
        { status: 404 }
      );
    }

    // 4. Validate quotation status
    if (quotation.status !== 'approved' && quotation.status !== 'APPROVED') {
      return NextResponse.json(
        {
          success: false,
          error: `注文を作成できるのは承認済みの見積のみです。現在のステータス: ${quotation.status}`,
          errorEn: `Only approved quotations can be converted to orders. Current status: ${quotation.status}`
        },
        { status: 400 }
      );
    }

    // 5. Check if quotation has items
    if (!quotation.quotation_items || quotation.quotation_items.length === 0) {
      return NextResponse.json(
        {
          success: false,
          error: '見積に項目が含まれていません。',
          errorEn: 'Quotation has no items'
        },
        { status: 400 }
      );
    }

    // 6. Create order from quotation
    const orderData = {
      user_id: user.id,
      status: 'QUOTATION' as OrderStatus, // Initial status in the 10-step workflow
      total_amount: quotation.total_amount,
      subtotal: quotation.subtotal_amount || Number(quotation.total_amount) * 0.909,
      tax_amount: quotation.tax_amount || Number(quotation.total_amount) * 0.091,
      customer_name: quotation.customer_name,
      customer_email: quotation.customer_email,
      customer_phone: quotation.customer_phone,
      notes: quotation.notes,
    };

    const { data: order, error: orderError } = await supabase
      .from('orders')
      .insert(orderData)
      .select()
      .single();

    if (orderError || !order) {
      console.error('[Order Confirm API] Order creation error:', orderError);
      return NextResponse.json(
        {
          success: false,
          error: '注文の作成に失敗しました。',
          errorEn: 'Failed to create order',
          details: orderError?.message
        },
        { status: 500 }
      );
    }

    // 7. Copy quotation items to order items
    const orderItemsToInsert = quotation.quotation_items.map(item => ({
      order_id: order.id,
      product_id: item.product_id,
      product_name: item.product_name,
      quantity: item.quantity,
      unit_price: item.unit_price,
      specifications: item.specifications,
    }));

    const { error: itemsError } = await supabase
      .from('order_items')
      .insert(orderItemsToInsert);

    if (itemsError) {
      console.error('[Order Confirm API] Order items creation error:', itemsError);
      // Rollback: delete order if items insertion fails
      await supabase.from('orders').delete().eq('id', order.id);

      return NextResponse.json(
        {
          success: false,
          error: '注文項目の作成に失敗しました。',
          errorEn: 'Failed to create order items',
          details: itemsError.message
        },
        { status: 500 }
      );
    }

    // 8. Update quotation items with order_id reference
    await supabase
      .from('quotation_items')
      .update({ order_id: order.id })
      .eq('quotation_id', quotation.id);

    // 9. Update quotation status to reflect conversion (optional)
    // Keep it as 'approved' since it's been used, or you could add a 'converted' status
    // For now, we'll leave the quotation status unchanged

    // 10. Prepare success response
    const response: ConfirmOrderResponse = {
      success: true,
      orderId: order.id,
      orderNumber: order.order_number,
      message: `注文を作成しました。注文番号: ${order.order_number}`,
      messageEn: `Order created successfully. Order number: ${order.order_number}`,
    };

    return NextResponse.json(response, { status: 201 });

  } catch (error) {
    console.error('[Order Confirm API] Unexpected error:', error);

    return NextResponse.json(
      {
        success: false,
        error: '予期しないエラーが発生しました。',
        errorEn: 'An unexpected error occurred',
        details: error instanceof Error ? error.message : String(error),
      },
      { status: 500 }
    );
  }
}

/**
 * GET /api/member/orders/confirm
 * Check if quotation can be confirmed (converted to order)
 *
 * Query Parameters:
 * - quotationId: The quotation ID to check
 *
 * Response:
 * {
 *   "canConfirm": boolean,
 *   "order": { ... } | null,
 *   "message": string
 * }
 */
export async function GET(request: NextRequest) {
  try {
    const searchParams = request.nextUrl.searchParams;
    const quotationId = searchParams.get('quotationId');

    if (!quotationId) {
      return NextResponse.json(
        { error: '見積IDは必須です', errorEn: 'quotationId is required' },
        { status: 400 }
      );
    }

    // Authenticate user
    const cookieStore = await cookies();
    const supabase = createClient(supabaseUrl, supabaseAnonKey, {
      auth: {
        storage: {
          getItem: (key: string) => {
            const cookie = cookieStore.get(key);
            return cookie?.value ?? null;
          },
          setItem: (key: string, value: string) => {
            cookieStore.set(key, value, {
              httpOnly: true,
              secure: process.env.NODE_ENV === 'production',
              sameSite: 'lax',
              path: '/',
            });
          },
          removeItem: (key: string) => {
            cookieStore.delete(key);
          },
        },
      },
    });

    // Check for DEV_MODE header from middleware
    const devModeUserId = request.headers.get('x-user-id');
    const isDevMode = request.headers.get('x-dev-mode') === 'true';

    let userId: string;

    if (isDevMode && devModeUserId) {
      // DEV_MODE: Use header from middleware
      console.log('[Order Confirm API GET] DEV_MODE: Using x-user-id header:', devModeUserId);
      userId = devModeUserId;
    } else {
      // Normal auth: Use cookie-based auth
      const { data: { user } } = await supabase.auth.getUser();

      if (!user) {
        return NextResponse.json(
          { error: '認証されていません', errorEn: 'Authentication required' },
          { status: 401 }
        );
      }
      userId = user.id;
    }

    // Check if quotation has been ordered
    const { data: order } = await supabase
      .from('orders')
      .select('id, order_number, status, created_at')
      .eq('quotation_id', quotationId)
      .maybeSingle();

    if (!order) {
      return NextResponse.json(
        {
          canConfirm: true,
          message: '注文可能です',
          messageEn: 'Order can be created'
        },
        { status: 200 }
      );
    }

    return NextResponse.json(
      {
        canConfirm: false,
        order: {
          id: order.id,
          orderNumber: order.order_number,
          status: order.status,
          createdAt: order.created_at,
        },
        message: 'この見積は既に注文されています',
        messageEn: 'This quotation has already been ordered'
      },
      { status: 200 }
    );
  } catch (error) {
    console.error('[Order Confirm API GET] Error:', error);
    return NextResponse.json(
      { error: 'ステータスの取得に失敗しました', errorEn: 'Failed to check status' },
      { status: 500 }
    );
  }
}

/**
 * OPTIONS handler for CORS preflight
 */
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 204,
    headers: {
      'Access-Control-Allow-Methods': 'POST, GET, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
      'Access-Control-Max-Age': '86400',
    },
  });
}
