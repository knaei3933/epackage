/**
 * Member Quotation Detail Page
 *
 * 会員見積書詳細ページ
 * - 見積情報の詳細表示
 * - 品目明細
 * - PDFダウンロード
 * - ドラフト状態の編集・削除
 * - 承認済み見積の注文変換
 */

'use client';

import { useState, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';
import { Card, Badge, Button } from '@/components/ui';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogDescription, DialogFooter } from '@/components/ui';
import { useAuth } from '@/contexts/AuthContext';
import { formatDistanceToNow } from 'date-fns';
import { ja } from 'date-fns/locale';
import {
  Download,
  Trash2,
  FileText,
  ArrowLeft,
  AlertCircle,
  Clock,
  CheckCircle,
  XCircle,
} from 'lucide-react';
import { generateQuotePDF, type QuoteData } from '@/lib/pdf-generator';
import { translateBagType, translateMaterialType } from '@/constants/enToJa';
import { BankInfoCard } from '@/components/quote/shared/BankInfoCard';
import { InvoiceDownloadButton } from '@/components/quote/shared/InvoiceDownloadButton';
import { getMaterialSpecification } from '@/lib/unified-pricing-engine';
import type { Quotation } from '@/types/dashboard';

// =====================================================
// Constants
// =====================================================

const quotationStatusLabels: Record<string, string> = {
  DRAFT: 'ドラフト',
  SENT: '送信済み',
  APPROVED: '承認済み',
  REJECTED: '却下',
  EXPIRED: '期限切れ',
  CONVERTED: '注文変換済み',
};

const quotationStatusVariants: Record<string, 'success' | 'secondary' | 'error' | 'warning' | 'info' | 'default'> = {
  DRAFT: 'secondary',
  SENT: 'info',
  APPROVED: 'success',
  REJECTED: 'error',
  EXPIRED: 'warning',
  CONVERTED: 'default',
};

// =====================================================
// Helper Functions
// =====================================================

/**
 * 袋タイプIDを日本語名に変換
 */
function getBagTypeName(bagTypeId: string): string {
  const names: Record<string, string> = {
    'flat_pouch': 'ピローパウチ',
    'flat_3_side': '三方シール平袋',
    'three_side_seal': '三方シール平袋',
    'stand_up': 'スタンドパウチ',
    'stand_pouch': 'スタンドパウチ',
    'gusset': 'ガセットパウチ',
    'gusset_pouch': 'ガセットパウチ',
    'roll_film': 'ロールフィルム',
    'roll-film': 'ロールフィルム',
    'zipper_pouch': 'ジッパーパウチ',
  };
  return names[bagTypeId] || translateBagType(bagTypeId) || bagTypeId || '-';
}

/**
 * 素材IDを日本語名に変換
 */
function getMaterialName(materialId: string): string {
  const names: Record<string, string> = {
    'pet_al': 'PET/AL (アルミ箔ラミネート)',
    'pet_ny_al': 'PET/NY/AL',
    'pet_pe': 'PET/PE (透明ラミネート)',
    'kp': 'kraft (クラフト紙)',
    'kraft': 'クラフト紙',
    'paper': '紙',
    'ny_pe': 'NY/PE',
    'pet_ny': 'PET/NY',
  };
  return names[materialId] || translateMaterialType(materialId) || materialId || '-';
}

/**
 * 厚さを材料構造で表示 (materialId + thicknessSelection から specification を取得)
 */
function getThicknessName(materialId: string, thicknessSelection: string, fallbackThickness?: string): string {
  // materialId と thicknessSelection の組み合わせから specification を取得
  if (materialId && thicknessSelection) {
    const spec = getMaterialSpecification(materialId, thicknessSelection);
    if (spec !== '-') return spec;
  }

  // フォールバック: 日本語変換
  const names: Record<string, string> = {
    'thin': '薄手',
    'standard': '標準',
    'medium': '中厚',
    'thick': '厚手',
    'extra_thick': '超厚手',
    'extra-thick': '超厚手',
    'light': '軽量',
    'heavy': '高耐久',
    'ultra': '超耐久',
  };
  return names[fallbackThickness || ''] || names[thicknessSelection] || fallbackThickness || thicknessSelection || '-';
}

/**
 * 내용물 정보를 일본어로 변환
 */
function getContentsDisplay(specs: Record<string, unknown> | undefined): string {
  if (!specs) return '-';

  const productCategoryMap: Record<string, string> = {
    'food': '食品',
    'health_supplement': '健康補助食品',
    'cosmetic': '化粧品',
    'quasi_drug': '医薬部外品',
    'drug': '医薬品',
  };
  const contentsTypeMap: Record<string, string> = {
    'solid': '固形',
    'powder': '粉体',
    'liquid': '液体',
  };
  const mainIngredientMap: Record<string, string> = {
    'general_neutral': '一般・中性',
    'oil_surfactant': '油性・界面活性剤',
    'acidic_salty': '酸性・塩分',
    'volatile_fragrance': '揮発性・香料',
    'other': 'その他',
  };
  const distributionEnvironmentMap: Record<string, string> = {
    'general_roomTemp': '一般（常温）',
    'light_oxygen_sensitive': '光・酸素敏感',
    'refrigerated': '冷蔵',
    'high_temp_sterilized': '高温殺菌',
    'other': 'その他',
  };

  const contents = [
    specs.productCategory ? productCategoryMap[specs.productCategory as string] : null,
    specs.contentsType ? contentsTypeMap[specs.contentsType as string] : null,
    specs.mainIngredient ? mainIngredientMap[specs.mainIngredient as string] : null,
    specs.distributionEnvironment ? distributionEnvironmentMap[specs.distributionEnvironment as string] : null,
  ].filter(Boolean).join('、');

  return contents || '-';
}

/**
 * Map database specifications to PDF template format
 */
function mapSpecificationsToPDF(specs: Record<string, unknown> | undefined): Record<string, string | boolean | number> {
  console.log('[mapSpecificationsToPDF] Input specs:', JSON.stringify(specs, null, 2));
  if (!specs) return {};

  const bagTypeId = specs.bagTypeId as string | undefined;
  const materialId = specs.materialId as string | undefined;
  const postProcessingOptions = specs.postProcessingOptions as string[] | undefined;
  console.log('[mapSpecificationsToPDF] postProcessingOptions:', postProcessingOptions);

  // サイズ表示 - ロールフィルムの場合は常に「幅: ○mm、ピッチ: ○mm」
  // 旧データ（二重ネスト）と新データ（修正後）の両方に対応
  const pitchValue = specs.pitch || (specs.specifications as any)?.pitch || 0;
  const sideWidth = specs.sideWidth as number | undefined;
  let sizeDisplay = '';
  if (bagTypeId === 'roll_film' || bagTypeId === 'spout_pouch') {
    sizeDisplay = `幅: ${specs.width || 0}mm${pitchValue ? `、ピッチ: ${pitchValue}mm` : ''}`;
  } else {
    // 既存のdimensionsがある場合はそれをベースに、なければ個別フィールドから構築
    const existingDimensions = specs.dimensions as string;
    if (existingDimensions) {
      // 既存のdimensionsに側面が含まれていない場合、追加する
      if (sideWidth && !existingDimensions.includes('側面')) {
        // dimensionsの最後の"mm"の前に側面を追加
        sizeDisplay = existingDimensions.replace(' mm', `${sideWidth ? `×側面${sideWidth}` : ''} mm`);
      } else {
        sizeDisplay = existingDimensions;
      }
    } else {
      // dimensionsがない場合は個別フィールドから構築
      sizeDisplay = `${specs.width || 0}×${specs.height || 0}${(specs.depth as number || 0) > 0 ? `×${specs.depth}` : ''}${sideWidth ? `×側面${sideWidth}` : ''}`;
    }
  }

  // ノッチ形状: postProcessingOptionsからマッピング
  let notchShape = 'V';
  if (postProcessingOptions?.includes('notch-straight')) {
    notchShape = '直線';
  } else if (postProcessingOptions?.includes('notch-no')) {
    notchShape = 'なし';
  }

  // 吊り下げ加工: postProcessingOptionsからマッピング
  let hanging = 'なし';
  let hangingPosition = '指定位置';
  if (postProcessingOptions?.includes('hang-hole-6mm')) {
    hanging = 'あり';
    hangingPosition = '6mm';
  } else if (postProcessingOptions?.includes('hang-hole-8mm')) {
    hanging = 'あり';
    hangingPosition = '8mm';
  }

  // 시일 폭: sealWidth 필드 또는 postProcessingOptions에서 추출
  let sealWidth = '5mm'; // 기본값
  const sealWidthField = specs.sealWidth as string | undefined;
  if (sealWidthField) {
    sealWidth = sealWidthField.replace('シール幅 ', '').replace('mm', '');
  } else {
    // postProcessingOptions에서 시일 폭 찾기
    const sealWidthOption = postProcessingOptions?.find((opt: string) => opt.startsWith('sealing-width-'));
    if (sealWidthOption) {
      const widthMatch = sealWidthOption.match(/sealing-width-(.+)$/);
      if (widthMatch) {
        sealWidth = widthMatch[1].replace('-', '.');
      }
    }
  }

  // 시일 방향 (기본값: 상단)
  const sealDirection = '上';

  const result = {
    bagType: bagTypeId ? translateBagType(bagTypeId) : 'スタンドパウチ',
    contents: '粉体',
    size: sizeDisplay,
    material: materialId ? translateMaterialType(materialId) : 'PET+AL',
    sealWidth,
    sealDirection,
    notchShape,
    notchPosition: (postProcessingOptions?.includes('notch-yes') || postProcessingOptions?.includes('notch-straight')) ? '指定位置' : undefined,
    hanging,
    hangingPosition,
    zipperPosition: postProcessingOptions?.some(opt => opt.includes('zipper') || opt.includes('zip')) ? '指定位置' : 'なし',
    cornerR: postProcessingOptions?.includes('corner-round') ? 'R5' : postProcessingOptions?.includes('corner-square') ? 'R0' : 'R5',
    machiPrinting: postProcessingOptions?.includes('machi-printing-yes') ? 'あり' : 'なし',
  };
  console.log('[mapSpecificationsToPDF] Result:', JSON.stringify(result, null, 2));
  return result;
}

// =====================================================
// Page Component
// =====================================================

export default function QuotationDetailPage() {
  const router = useRouter();
  const params = useParams();
  const quotationId = params.id as string;
  const { user, profile } = useAuth();

  const [quotation, setQuotation] = useState<Quotation | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [isDeleting, setIsDeleting] = useState(false);
  const [downloadingPDF, setDownloadingPDF] = useState(false);
  const [downloadHistory, setDownloadHistory] = useState<any[]>([]);
  const [downloadCount, setDownloadCount] = useState(0);
  const [lastDownloadedAt, setLastDownloadedAt] = useState<string | null>(null);
  const [isConverting, setIsConverting] = useState(false);
  const [convertError, setConvertError] = useState<string | null>(null);

  // Redirect to login if not authenticated
  useEffect(() => {
    if (!user && !isLoading) {
      router.push('/auth/signin?redirect=/member/quotations');
    }
  }, [user, isLoading, router]);

  // Fetch quotation details
  const fetchQuotation = async () => {
    if (!user?.id) return;

    setIsLoading(true);
    setError(null);

    try {
      const response = await fetch(`/api/member/quotations/${quotationId}`, {
        credentials: 'include',
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || 'Failed to fetch quotation');
      }

      const { quotation: quotationData } = await response.json();
      setQuotation(quotationData);
    } catch (err) {
      console.error('Failed to fetch quotation:', err);
      setError('見積の取得に失敗しました');
    } finally {
      setIsLoading(false);
    }
  };

  // Fetch download history
  const fetchDownloadHistory = async () => {
    try {
      const response = await fetch(`/api/member/documents/history?quotation_id=${quotationId}`, {
        credentials: 'include',
      });

      if (response.ok) {
        const { data } = await response.json();
        setDownloadHistory(data.history || []);
        setDownloadCount(data.statistics.downloadCount || 0);
        setLastDownloadedAt(data.statistics.lastDownloadedAt);
      }
    } catch (err) {
      console.error('Failed to fetch download history:', err);
    }
  };

  useEffect(() => {
    if (user?.id && quotationId) {
      fetchQuotation();
      fetchDownloadHistory();
    }
  }, [user?.id, quotationId]);

  const handleDownloadPDF = async () => {
    console.log('[handleDownloadPDF] ========== START ==========');
    if (!quotation) return;

    setDownloadingPDF(true);

    try {
      console.log('[handleDownloadPDF] quotation.items:', quotation.items);
      console.log('[handleDownloadPDF] quotation.items[0]?.specifications:', JSON.stringify(quotation.items[0]?.specifications, null, 2));
      if (!quotation.items || quotation.items.length === 0) {
        throw new Error('見積明細がありません');
      }

      const formatDate = (dateStr: string | null) => {
        if (!dateStr) return '';
        const date = new Date(dateStr);
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        return `${year}-${month}-${day}`;
      };

      const quoteItems = quotation.items
        .filter((item) => item.productName && item.quantity > 0 && item.unitPrice >= 0)
        .map((item) => {
          const specs = item.specifications as Record<string, unknown> | undefined;
          const materialId = specs?.materialId as string | undefined;
          const dimensions = specs?.dimensions as string | undefined;
          const bagTypeId = specs?.bagTypeId as string | undefined;

          // サイズ表示 - ロールフィルムの場合は常に「幅: ○mm、ピッチ: ○mm」
          // 旧データ（二重ネスト）と新データ（修正後）の両方に対応
          let sizeText: string;
          if (bagTypeId === 'roll_film' || bagTypeId === 'spout_pouch') {
            const pitchVal = specs?.pitch || (specs?.specifications as any)?.pitch || 0;
            sizeText = `幅: ${specs?.width || 0}mm${pitchVal ? `、ピッチ: ${pitchVal}mm` : ''}`;
          } else {
            const itemSideWidth = specs?.sideWidth as number | undefined;
            if (dimensions) {
              // 既存のdimensionsに側面が含まれていない場合、追加する
              if (itemSideWidth && !dimensions.includes('側面')) {
                sizeText = dimensions.replace(' mm', `${itemSideWidth ? `×側面${itemSideWidth}` : ''} mm`);
              } else {
                sizeText = dimensions;
              }
            } else {
              // dimensionsがない場合は個別フィールドから構築
              sizeText = `${specs?.width || 0}×${specs?.height || 0}${(specs?.depth as number || 0) > 0 ? `×${specs.depth}` : ''}${itemSideWidth ? `×側面${itemSideWidth}` : ''}`;
            }
          }

          return {
            id: item.id,
            name: item.productName || '製品名なし',
            description: sizeText
              ? `サイズ: ${sizeText} | ${materialId ? translateMaterialType(materialId) : '-'}`
              : '-',
            quantity: item.quantity || 0,
            unit: '個',
            unitPrice: Math.round(item.unitPrice || 0),
            amount: Math.round(item.totalPrice || item.unitPrice * item.quantity || 0),
          };
        });

      if (quoteItems.length === 0) {
        throw new Error('有効な見積明細がありません');
      }

      const pdfData = {
        quoteNumber: quotation.quotationNumber,
        issueDate: formatDate(quotation.createdAt),
        expiryDate: formatDate(quotation.validUntil),
        quoteCreator: 'EPACKAGE Lab 見積システム',
        customerName: profile?.kanji_last_name && profile?.kanji_first_name
          ? `${profile.kanji_last_name} ${profile.kanji_first_name}`
          : (profile?.company_name || user?.email?.split('@')[0] || 'お客様'),
        customerNameKana: profile?.kana_last_name && profile?.kana_first_name
          ? `${profile.kana_last_name} ${profile.kana_first_name}`
          : '',
        companyName: profile?.company_name || '',
        postalCode: profile?.postal_code || '',
        address: (profile?.prefecture || profile?.city || profile?.street)
          ? `${profile?.prefecture || ''}${profile?.city || ''}${profile?.street || ''}`
          : '',
        contactPerson: profile?.kanji_last_name && profile?.kanji_first_name
          ? `${profile.kanji_last_name} ${profile.kanji_first_name}`
          : '',
        phone: profile?.corporate_phone || profile?.personal_phone || '',
        email: user?.email || '',
        items: quoteItems,
        specifications: (() => {
          console.log('[handleDownloadPDF] Calling mapSpecificationsToPDF with:', quotation.items[0]?.specifications);
          const specs = mapSpecificationsToPDF(quotation.items[0]?.specifications);
          console.log('[handleDownloadPDF] mapSpecificationsToPDF returned:', specs);
          return specs;
        })(),
        optionalProcessing: (() => {
          const allPostProcessingOptions = quotation.items.flatMap(item =>
            (item.specifications?.postProcessingOptions as string[]) || []
          );
          return {
            zipper: allPostProcessingOptions.some(opt => opt.includes('zipper') || opt.includes('zip')),
            notch: allPostProcessingOptions.some(opt => opt.includes('notch') || opt.includes('tear')),
            hangingHole: allPostProcessingOptions.some(opt => opt.includes('hang') || opt.includes('hole')),
            cornerProcessing: allPostProcessingOptions.some(opt => opt.includes('corner') || opt.includes('r')),
          };
        })(),
        paymentTerms: '先払い',
        deliveryDate: '校了から約1か月',
        deliveryLocation: '指定なし',
        validityPeriod: '見積発行から3ヶ月間',
        remarks: `※製造工程上の都合により、実際の納品数量はご注文数量に対し最大10％程度の過不足が生じる場合がございます。
数量の完全保証はいたしかねますので、あらかじめご了承ください。
※不足分につきましては、実際に納品した数量に基づきご請求いたします。
前払いにてお支払いいただいた場合は、差額分を返金いたします。
※原材料価格の変動等により、見積有効期限経過後は価格が変更となる場合がございます。
再見積の際は、あらかじめご了承くださいますようお願いいたします。
※本見積金額には郵送費を含んでおります。
※お客様によるご確認の遅れ、その他やむを得ない事情により、納期が前後する場合がございます。
※年末年始等の長期休暇期間を挟む場合、通常より納期が延びる可能性がございます。
※天候不良、事故、交通事情等の影響により、やむを得ず納期が遅延する場合がございますので、あらかじめご了承ください。`,
      };

      const result = await generateQuotePDF(pdfData as QuoteData, {
        filename: `${quotation.quotationNumber}.pdf`,
      });

      if (!result.success || !result.pdfBuffer) {
        throw new Error(result.error || 'PDF generation failed');
      }

      const uint8Array = new Uint8Array(result.pdfBuffer);
      const blob = new Blob([uint8Array], { type: 'application/pdf' });
      const url = window.URL.createObjectURL(blob);

      // 新しいタブでPDFを開く
      window.open(url, '_blank');

      // Cleanup
      setTimeout(() => {
        window.URL.revokeObjectURL(url);
      }, 1000);

      // PDFをSupabase Storageに保存してpdf_urlを更新（管理者ページで同じPDFを使用するため）
      try {
        // Uint8Arrayをbase64に変換
        const binaryString = uint8Array.reduce((acc, byte) => acc + String.fromCharCode(byte), '');
        const base64Data = btoa(binaryString);
        const dataUrl = `data:application/pdf;base64,${base64Data}`;

        await fetch(`/api/member/quotations/${quotationId}/save-pdf`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          credentials: 'include',
          body: JSON.stringify({ pdfData: dataUrl }),
        });

        console.log('[handleDownloadPDF] PDF saved to Supabase Storage, pdf_url updated');
      } catch (saveError) {
        console.error('[handleDownloadPDF] Failed to save PDF to storage:', saveError);
